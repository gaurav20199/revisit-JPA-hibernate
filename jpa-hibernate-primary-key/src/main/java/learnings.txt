Primary ID Generation Strategy
We can use GeneratedValue annotation with strategy.
Not all the strategy works with every database.
Strategy can be Identity->
It expects values generated by an identity column in the database. ID(s) are Auto Incremented.
IDENTITY generation disables batch updates.

By default, Hibernate uses Sequence Strategy.

Strategy can be Table::
The TableGenerator uses an underlying database table that holds segments of identifier generation values.
With this there is a hibernate_sequence table created as well that holds generated values.
The new entry that we will add will be based on the last value of the hibernate_sequence table.
It's not really recommended but this strategy works with almost all the relational db(s).

Strategy can be Auto::
The persistence provider will determine values based on the type of the primary key attribute.
For numeric values,the generation is based on a sequence or table generator,while UUID values will use the UUIDGenerator

Strategy can be Sequence::
Hibernate creates a hibernate_sequence tables and stores the key in it. For assigning a new key, it usually takes the
last generated key and increment it by 1 and assign it as new key.
We can define our own Sequence Generator as well.
This generator uses sequences if our database supports them. It switches to table generation if they arenâ€™t supported.

Strategy can be UUID(Universal Unique Identifier)
This is new addition in Jakarta api. Used to generate uuid(s).
UUID(s) are not that good considering performance as indexing on string values is not that performant.
UUID(s) can be used with DB internal id. UUID(s) are quite good for exposing id(s) in form of uuid(s) to the
client/frontend. This ensures that db-id is not actually getting exposed to frontend.

Creating Your Custom Generator
1) Before Hibernate version 6.5 we can use the GenericGenerator and provide it with the custom generator class
(UUIDGenerator in our case to it) and that would have worked but this has been deprecated.
2) We can use IdGeneratorType which is a meta annotation,and we have to create our own annotation(UUIDGeneratorType)
and this can be put on the entity field.

Defining Composite Primary Key
There are two ways to define composite primary key
1) Using IdClass
2) Using Embeddable

NOTE: While defining Composite Primary Key it should be important to implement hashcode and equals method.

Using IdClass
1) Define a separate class having only those attributes which will be part of Composite Primary Key.
Eg: CompositeEmployeeKey class have empCode and department. Attributes name should be exact same as in the Entity class.
2) Use @IdClass annotation and provide the class name created in step 1
3) Use @Id annotation on the Entity class above all the fields that will be part of the Composite Primary Key.

Using Embeddable
1) Define a separate class having only those attributes which will be part of Composite Primary Key. Mark it with
Embeddable annotation.
Eg: CompositeStudentKey class have rollNo and department.
2) Define the CompositeStudentKey in the Entity class along with the other attributes which will be part of Student but
not part of Primary Key.
3) Use @EmbeddedId annotation instead of @Id annotation.

